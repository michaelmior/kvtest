\documentclass{sig-alternate-2013}

\pdfminorversion=4
\pdfimageresolution=600

\usepackage{caption}
\usepackage{subfig}
\usepackage{todonotes}
\usepackage[hidelinks]{hyperref}
\usepackage{fixltx2e}
\usepackage{enumitem}
\usepackage[english]{babel}
\usepackage{microtype}

\clubpenalty=10000
\widowpenalty=10000

\makeatletter
\def\@copyrightspace{\relax}
\makeatother

\begin{document}

\hypersetup{pdftitle=Congestion-Aware Join Optimization in Key-Value Stores}
\hypersetup{pdfauthor={Xu Cui, Michael Mior, and Xinan Yan}}

\title{Congestion-Aware Join Optimization in Key-Value Stores}

\numberofauthors{3}
\author{
    \alignauthor{
        Xu Cui\\
        \affaddr{University of Waterloo}\\
        \email{xcui@uwaterloo.ca}
    }
    \alignauthor{
        Michael Mior\\
        \affaddr{University of Waterloo}\\
        \email{mmior@uwaterloo.ca}
    }
    \alignauthor{
        Xinan Yan\\
        \affaddr{University of Waterloo}\\
        \email{x29yan@uwaterloo.ca}
    }
}

\maketitle

\begin{abstract}
Applications which use key-value stores to execute higher-level queries may need to follow references obtained from previous keys.
In the case where all data is contained in main memory, the bottleneck becomes the network transfer of values from the datastore to the application.
When some keys become highly popular, network links to machines hosting these keys can become saturated and affect application performance.
We demonstrate an approach that takes advantage of replication and network performance measurements to effectively route requests over underutilized links.
\end{abstract}

\section{Introduction}

\section{System Overview}

\subsection{Query Model}

\subsection{Architecture}

If we were to use fair share allocation, then the node with the largest share of the query results, bottlenecked by available bandwidth, would become a straggler.
Nodes with a small share of query results could finish much more quickly only to wait for these stragglers.
To minimize the overall completion time of queries, we can allocate bandwidth to each node as the fraction of query results which will be returned by the node.
This will speed up stragglers at the expense of slowing down nodes with a smaller allocation.
However, the net result is a reduction in the average execution cost.

We currently deal with a read-only workload where the distribution of data is known by all nodes.
Each node is able to calculate the fraction of query results it will return.

\section{Related Work}

The majority of work on query processing in key-value stores is in executing queries on data stored in distributed hash tables (DHTs) in peer-to-peer (P2P) networks.
For example, Harren et al.~\cite{Harren2002} propose a basic query model for executing complex queries in this scenario.
Their approach aims to minimize communication cost, but it is designed for P2P systems where the network is not under control of the application and is therefore unable to make use of network-aware techniques.
PIER~\cite{Huebsch2005} is a similar query processing engine over DHTs which is also not network-aware.
However, the query processing model used by PIER may be an interesting area to explore.

\section{Evaluation}

We run all our experiments on a simulated network on a single machine using Mininet~\cite{Lantz2010}.

\section{Future Work}

There are many opportunities to combine this work with appropriate key placement strategies for further performance optimizations.
For heterogenous networks, a key placement strategy which is network and workload aware may provide significant performance advantages.
Our current query execution model is very simplistic and could be expanded to support richer queries and distributed index data structures.
We would also like to investigate other query types such as aggregation which we suspect would also benefit from our approach.
Finally, our current system requires all intermediate values to be sent to the application which then coordinates all requests.
Making the datastore a participant in query execution would reduce network bandwidth by allowing individual servers to follow the links between keys.

We also have not dealt with the possibility of updates as well as replication.
There is potential to further exploit SDN techniques by allowing low latency updates to data in the presence of the high bandwidth flows used for query processing.

\section{Conclusion}

\let\theOLDbibliography\thebibliography\renewcommand{\thebibliography}[1]{\theOLDbibliography{#1}%
\item[]\vspace*{0.5mm}}

\bibliographystyle{abbrv}
{\scriptsize
\bibliography{paper}
}

\end{document}
