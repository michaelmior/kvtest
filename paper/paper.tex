\documentclass{sig-alternate-2013}

\pdfminorversion=4
\pdfimageresolution=600

\usepackage{caption}
\usepackage{subfig}
\usepackage{todonotes}
\usepackage[hidelinks]{hyperref}
\usepackage{fixltx2e}
\usepackage{enumitem}
\usepackage[english]{babel}
\usepackage{microtype}

\clubpenalty=10000
\widowpenalty=10000

\makeatletter
\def\@copyrightspace{\relax}
\makeatother

\begin{document}

\hypersetup{pdftitle=Congestion-Aware Join Optimization in Key-Value Stores}
\hypersetup{pdfauthor={Xu Cui, Michael Mior, and Xinan Yan}}

\title{Congestion-Aware Join Optimization in Key-Value Stores}

\numberofauthors{3}
\author{
    \alignauthor{
        Xu Cui\\
        \affaddr{University of Waterloo}\\
        \email{xcui@uwaterloo.ca}
    }
    \alignauthor{
        Michael Mior\\
        \affaddr{University of Waterloo}\\
        \email{mmior@uwaterloo.ca}
    }
    \alignauthor{
        Xinan Yan\\
        \affaddr{University of Waterloo}\\
        \email{x29yan@uwaterloo.ca}
    }
}

\maketitle

\begin{abstract}
Applications which use key-value stores to execute higher-level queries need to aggregate data from multiple nodes.
In the case where all data is contained in main memory, the bottleneck becomes the network transfer of values from the datastore to the application.
When some keys become highly popular, network links to machines hosting these keys can become saturated and affect application performance.
In addition, nodes will compete with each other for bandwidth and uninformed traffic prioritization can result in reduced query execution time.
We demonstrate an approach that takes advantage of replication and network performance measurements to effectively route requests over underutilized links.
\end{abstract}

\section{Introduction}

\section{System Overview}

\subsection{Query Model}

\subsection{Architecture}

\subsection{Flow Scheduling}

Simple approaches to bandwith allocation such as max-min fairness pose significant problems in our settings.
If we were to use fair share allocation, then the node with the largest share of the query results, bottlenecked by available bandwidth, would become a straggler.
Nodes with a small share of query results could finish much more quickly only to wait for these stragglers.
To minimize the overall completion time of queries, we can allocate bandwidth to each node as the fraction of query results which will be returned by the node.
This will speed up stragglers at the expense of slowing down nodes with a smaller allocation.
However, the net result is a reduction in the average execution cost.

We currently deal with a read-only workload where the distribution of data is known by all nodes.
Each node is able to calculate the fraction of query results it will return.
A node can signal the expected fraction of the results for a query it will return by setting bits within the packet header.
When a new flow is issued for query processing, the controller can inspect these bits and assign an appropriate priority to each flow.

\section{Related Work}

The majority of work on query processing in key-value stores is in executing queries on data stored in distributed hash tables (DHTs) in peer-to-peer (P2P) networks.
For example, Harren et al.~\cite{Harren2002} propose a basic query model for executing complex queries in this scenario.
Their approach aims to minimize communication cost, but it is designed for P2P systems where the network is not under control of the application and is therefore unable to make use of network-aware techniques.
PIER~\cite{Huebsch2005} is a similar query processing engine over DHTs which is also not network-aware.
However, the query processing model used by PIER may be an interesting area to explore.

There has also been some work in exploiting software-defined networking for big data applications.
Wang et al.~\cite{Wang2012} examined network traffic patterns in a Hadoop cluster and identified opportunities to combine network-aware job scheduling with dynamic routing configuration to improve job completion time.
Xiong et al.~\cite{Xiong2014} examine the usefulness of software-defined networking in supporting distributed analytical queries.
Their workload consits of read-only SQL queries where query processing is bandwidth-intensive.
They construct a global query optimizer which decides on join order and how query results should be passed between sites.
This work takes a similar approach to ours, but also identifies many opportunities for further work.

\section{Evaluation}

We run all our experiments on a simulated network on a single machine using Mininet~\cite{Lantz2010}.
We use Open vSwitch~\cite{Pfaff2009} as our switch which supports queues with varying bandwidth guarantees.
Our controller uses the POX~\cite{Gude2008} platform and OpenFlow~\cite{McKeown2008} 1.0.

Queries use data taken from the RUBiS~\cite{Cecchet2002} benchmark, which is a Web application simulating an online auction.
We distribute data on users and the items they are selling between all nodes with no replication.

\section{Future Work}

There are many opportunities to combine this work with appropriate key placement strategies for further performance optimizations.
For heterogenous networks, a key placement strategy which is network and workload aware may provide significant performance advantages.
Our current query execution model is very simplistic and could be expanded to support richer queries and distributed index data structures.
We would also like to investigate other query types such as aggregation which we suspect would also benefit from our approach.
This presents new challenges in network scheduling, especially in the face of concurrent queries of multiple different types.

Our current system also does not deal with the possibility of updates or replication.
There is potential to further exploit SDN techniques by allowing low latency updates to data in the presence of the high bandwidth flows used for query processing.
Replication provides further opportunity for optimization as flows can be routed to multiple possible locations to avoid bottleneck links.

\section{Conclusion}

\let\theOLDbibliography\thebibliography\renewcommand{\thebibliography}[1]{\theOLDbibliography{#1}%
\item[]\vspace*{0.5mm}}

\bibliographystyle{abbrv}
{\scriptsize
\bibliography{paper}
}

\end{document}
